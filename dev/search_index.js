var documenterSearchIndex = {"docs":
[{"location":"custom_gates/","page":"Custom Gates","title":"Custom Gates","text":"CurrentModule = BraketSimulator","category":"page"},{"location":"custom_gates/#Custom-gates","page":"Custom Gates","title":"Custom gates","text":"","category":"section"},{"location":"custom_gates/","page":"Custom Gates","title":"Custom Gates","text":"BraketSimulator.jl defines some custom gates to extend what Braket.jl provides.","category":"page"},{"location":"custom_gates/","page":"Custom Gates","title":"Custom Gates","text":"BraketSimulator.MultiRZ","category":"page"},{"location":"custom_gates/#BraketSimulator.MultiRZ","page":"Custom Gates","title":"BraketSimulator.MultiRZ","text":"MultiRz(angle)\n\nMulti-qubit Z-rotation gate. The 2-qubit version is equivalent to the ZZ gate, and the single-qubit version is equivalent to the Rz gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/","page":"Gates","title":"Gates","text":"CurrentModule = BraketSimulator","category":"page"},{"location":"gates/#Gates","page":"Gates","title":"Gates","text":"","category":"section"},{"location":"gates/","page":"Gates","title":"Gates","text":"BraketSimulators.jl provides many pre-implemented gates which can be used to build up circuits. For gates with angle parameters, you can supply Irrationals like π as arguments.","category":"page"},{"location":"gates/","page":"Gates","title":"Gates","text":"BraketSimulator.Gate\nBraketSimulator.AngledGate\nBraketSimulator.I\nBraketSimulator.X\nBraketSimulator.Y\nBraketSimulator.Z\nBraketSimulator.H\nBraketSimulator.Rx\nBraketSimulator.Ry\nBraketSimulator.Rz\nBraketSimulator.V\nBraketSimulator.Vi\nBraketSimulator.T\nBraketSimulator.Ti\nBraketSimulator.S\nBraketSimulator.Si\nBraketSimulator.U\nBraketSimulator.Unitary\nBraketSimulator.PhaseShift\nBraketSimulator.MultiQubitPhaseShift\nBraketSimulator.PRx\nBraketSimulator.GPi\nBraketSimulator.GPi2\nBraketSimulator.XX\nBraketSimulator.XY\nBraketSimulator.YY\nBraketSimulator.ZZ\nBraketSimulator.ECR\nBraketSimulator.MS\nBraketSimulator.CPhaseShift\nBraketSimulator.CPhaseShift00\nBraketSimulator.CPhaseShift01\nBraketSimulator.CPhaseShift10\nBraketSimulator.CNot\nBraketSimulator.CY\nBraketSimulator.CZ\nBraketSimulator.CV\nBraketSimulator.Swap\nBraketSimulator.PSwap\nBraketSimulator.ISwap\nBraketSimulator.CCNot\nBraketSimulator.CSwap","category":"page"},{"location":"gates/#BraketSimulator.Gate","page":"Gates","title":"BraketSimulator.Gate","text":"Gate <: QuantumOperator\n\nAbstract type representing a quantum gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#BraketSimulator.AngledGate","page":"Gates","title":"BraketSimulator.AngledGate","text":"AngledGate{NA} <: Gate\n\nParametric type representing a quantum gate with NA angle parameters.\n\n\n\n\n\n","category":"type"},{"location":"gates/#BraketSimulator.I","page":"Gates","title":"BraketSimulator.I","text":"BraketSimulator.I <: Gate\nBraketSimulator.I() -> BraketSimulator.I\n\nBraketSimulator.I gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#BraketSimulator.X","page":"Gates","title":"BraketSimulator.X","text":"BraketSimulator.X <: Gate\nBraketSimulator.X() -> BraketSimulator.X\n\nBraketSimulator.X gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#BraketSimulator.Y","page":"Gates","title":"BraketSimulator.Y","text":"BraketSimulator.Y <: Gate\nBraketSimulator.Y() -> BraketSimulator.Y\n\nBraketSimulator.Y gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#BraketSimulator.Z","page":"Gates","title":"BraketSimulator.Z","text":"BraketSimulator.Z <: Gate\nBraketSimulator.Z() -> BraketSimulator.Z\n\nBraketSimulator.Z gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#BraketSimulator.H","page":"Gates","title":"BraketSimulator.H","text":"BraketSimulator.H <: Gate\nBraketSimulator.H() -> BraketSimulator.H\n\nBraketSimulator.H gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#BraketSimulator.Rx","page":"Gates","title":"BraketSimulator.Rx","text":"BraketSimulator.Rx <: AngledGate{1}\nBraketSimulator.Rx(angles) -> BraketSimulator.Rx\n\nBraketSimulator.Rx gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#BraketSimulator.Ry","page":"Gates","title":"BraketSimulator.Ry","text":"BraketSimulator.Ry <: AngledGate{1}\nBraketSimulator.Ry(angles) -> BraketSimulator.Ry\n\nBraketSimulator.Ry gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#BraketSimulator.Rz","page":"Gates","title":"BraketSimulator.Rz","text":"BraketSimulator.Rz <: AngledGate{1}\nBraketSimulator.Rz(angles) -> BraketSimulator.Rz\n\nBraketSimulator.Rz gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#BraketSimulator.V","page":"Gates","title":"BraketSimulator.V","text":"BraketSimulator.V <: Gate\nBraketSimulator.V() -> BraketSimulator.V\n\nBraketSimulator.V gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#BraketSimulator.Vi","page":"Gates","title":"BraketSimulator.Vi","text":"BraketSimulator.Vi <: Gate\nBraketSimulator.Vi() -> BraketSimulator.Vi\n\nBraketSimulator.Vi gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#BraketSimulator.T","page":"Gates","title":"BraketSimulator.T","text":"BraketSimulator.T <: Gate\nBraketSimulator.T() -> BraketSimulator.T\n\nBraketSimulator.T gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#BraketSimulator.Ti","page":"Gates","title":"BraketSimulator.Ti","text":"BraketSimulator.Ti <: Gate\nBraketSimulator.Ti() -> BraketSimulator.Ti\n\nBraketSimulator.Ti gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#BraketSimulator.S","page":"Gates","title":"BraketSimulator.S","text":"BraketSimulator.S <: Gate\nBraketSimulator.S() -> BraketSimulator.S\n\nBraketSimulator.S gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#BraketSimulator.Si","page":"Gates","title":"BraketSimulator.Si","text":"BraketSimulator.Si <: Gate\nBraketSimulator.Si() -> BraketSimulator.Si\n\nBraketSimulator.Si gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#BraketSimulator.U","page":"Gates","title":"BraketSimulator.U","text":"BraketSimulator.U <: AngledGate{3}\nBraketSimulator.U(angles) -> BraketSimulator.U\n\nBraketSimulator.U gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#BraketSimulator.Unitary","page":"Gates","title":"BraketSimulator.Unitary","text":"Unitary <: Gate\nUnitary(matrix::Matrix{ComplexF64}) -> Unitary\n\nArbitrary unitary gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#BraketSimulator.PhaseShift","page":"Gates","title":"BraketSimulator.PhaseShift","text":"BraketSimulator.PhaseShift <: AngledGate{1}\nBraketSimulator.PhaseShift(angles) -> BraketSimulator.PhaseShift\n\nBraketSimulator.PhaseShift gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#BraketSimulator.MultiQubitPhaseShift","page":"Gates","title":"BraketSimulator.MultiQubitPhaseShift","text":"MultiQubitPhaseShift{N}(angle)\n\nGlobal phase shift on N qubits. Equivalent to the OpenQASM3 built-in gphase gate. Controls/negative controls applied to this gate control which states are rotated, so that Control(g::MultiQubitPhaseShift{2}) will apply the rotation to the |11> state.\n\n\n\n\n\n","category":"type"},{"location":"gates/#BraketSimulator.PRx","page":"Gates","title":"BraketSimulator.PRx","text":"BraketSimulator.PRx <: AngledGate{2}\nBraketSimulator.PRx(angles) -> BraketSimulator.PRx\n\nBraketSimulator.PRx gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#BraketSimulator.GPi","page":"Gates","title":"BraketSimulator.GPi","text":"BraketSimulator.GPi <: AngledGate{1}\nBraketSimulator.GPi(angles) -> BraketSimulator.GPi\n\nBraketSimulator.GPi gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#BraketSimulator.GPi2","page":"Gates","title":"BraketSimulator.GPi2","text":"BraketSimulator.GPi2 <: AngledGate{1}\nBraketSimulator.GPi2(angles) -> BraketSimulator.GPi2\n\nBraketSimulator.GPi2 gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#BraketSimulator.XX","page":"Gates","title":"BraketSimulator.XX","text":"BraketSimulator.XX <: AngledGate{1}\nBraketSimulator.XX(angles) -> BraketSimulator.XX\n\nBraketSimulator.XX gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#BraketSimulator.XY","page":"Gates","title":"BraketSimulator.XY","text":"BraketSimulator.XY <: AngledGate{1}\nBraketSimulator.XY(angles) -> BraketSimulator.XY\n\nBraketSimulator.XY gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#BraketSimulator.YY","page":"Gates","title":"BraketSimulator.YY","text":"BraketSimulator.YY <: AngledGate{1}\nBraketSimulator.YY(angles) -> BraketSimulator.YY\n\nBraketSimulator.YY gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#BraketSimulator.ZZ","page":"Gates","title":"BraketSimulator.ZZ","text":"BraketSimulator.ZZ <: AngledGate{1}\nBraketSimulator.ZZ(angles) -> BraketSimulator.ZZ\n\nBraketSimulator.ZZ gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#BraketSimulator.ECR","page":"Gates","title":"BraketSimulator.ECR","text":"BraketSimulator.ECR <: Gate\nBraketSimulator.ECR() -> BraketSimulator.ECR\n\nBraketSimulator.ECR gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#BraketSimulator.MS","page":"Gates","title":"BraketSimulator.MS","text":"BraketSimulator.MS <: AngledGate{3}\nBraketSimulator.MS(angles) -> BraketSimulator.MS\n\nBraketSimulator.MS gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#BraketSimulator.CPhaseShift","page":"Gates","title":"BraketSimulator.CPhaseShift","text":"BraketSimulator.CPhaseShift <: AngledGate{1}\nBraketSimulator.CPhaseShift(angles) -> BraketSimulator.CPhaseShift\n\nBraketSimulator.CPhaseShift gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#BraketSimulator.CPhaseShift00","page":"Gates","title":"BraketSimulator.CPhaseShift00","text":"BraketSimulator.CPhaseShift00 <: AngledGate{1}\nBraketSimulator.CPhaseShift00(angles) -> BraketSimulator.CPhaseShift00\n\nBraketSimulator.CPhaseShift00 gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#BraketSimulator.CPhaseShift01","page":"Gates","title":"BraketSimulator.CPhaseShift01","text":"BraketSimulator.CPhaseShift01 <: AngledGate{1}\nBraketSimulator.CPhaseShift01(angles) -> BraketSimulator.CPhaseShift01\n\nBraketSimulator.CPhaseShift01 gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#BraketSimulator.CPhaseShift10","page":"Gates","title":"BraketSimulator.CPhaseShift10","text":"BraketSimulator.CPhaseShift10 <: AngledGate{1}\nBraketSimulator.CPhaseShift10(angles) -> BraketSimulator.CPhaseShift10\n\nBraketSimulator.CPhaseShift10 gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#BraketSimulator.CNot","page":"Gates","title":"BraketSimulator.CNot","text":"BraketSimulator.CNot <: Gate\nBraketSimulator.CNot() -> BraketSimulator.CNot\n\nBraketSimulator.CNot gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#BraketSimulator.CY","page":"Gates","title":"BraketSimulator.CY","text":"BraketSimulator.CY <: Gate\nBraketSimulator.CY() -> BraketSimulator.CY\n\nBraketSimulator.CY gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#BraketSimulator.CZ","page":"Gates","title":"BraketSimulator.CZ","text":"BraketSimulator.CZ <: Gate\nBraketSimulator.CZ() -> BraketSimulator.CZ\n\nBraketSimulator.CZ gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#BraketSimulator.CV","page":"Gates","title":"BraketSimulator.CV","text":"BraketSimulator.CV <: Gate\nBraketSimulator.CV() -> BraketSimulator.CV\n\nBraketSimulator.CV gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#BraketSimulator.Swap","page":"Gates","title":"BraketSimulator.Swap","text":"BraketSimulator.Swap <: Gate\nBraketSimulator.Swap() -> BraketSimulator.Swap\n\nBraketSimulator.Swap gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#BraketSimulator.PSwap","page":"Gates","title":"BraketSimulator.PSwap","text":"BraketSimulator.PSwap <: AngledGate{1}\nBraketSimulator.PSwap(angles) -> BraketSimulator.PSwap\n\nBraketSimulator.PSwap gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#BraketSimulator.ISwap","page":"Gates","title":"BraketSimulator.ISwap","text":"BraketSimulator.ISwap <: Gate\nBraketSimulator.ISwap() -> BraketSimulator.ISwap\n\nBraketSimulator.ISwap gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#BraketSimulator.CCNot","page":"Gates","title":"BraketSimulator.CCNot","text":"BraketSimulator.CCNot <: Gate\nBraketSimulator.CCNot() -> BraketSimulator.CCNot\n\nBraketSimulator.CCNot gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#BraketSimulator.CSwap","page":"Gates","title":"BraketSimulator.CSwap","text":"BraketSimulator.CSwap <: Gate\nBraketSimulator.CSwap() -> BraketSimulator.CSwap\n\nBraketSimulator.CSwap gate.\n\n\n\n\n\n","category":"type"},{"location":"results/#Results","page":"Results","title":"Results","text":"","category":"section"},{"location":"results/","page":"Results","title":"Results","text":"BraketSimulator.Result\nBraketSimulator.AdjointGradient\nBraketSimulator.Expectation\nBraketSimulator.Variance\nBraketSimulator.Sample\nBraketSimulator.Amplitude\nBraketSimulator.Probability\nBraketSimulator.DensityMatrix\nBraketSimulator.StateVector","category":"page"},{"location":"results/#BraketSimulator.Result","page":"Results","title":"BraketSimulator.Result","text":"Result\n\nAbstract type representing a measurement to perform on a Circuit.\n\nSee also: Expectation, Variance, Sample, Probability, DensityMatrix, and Amplitude.\n\n\n\n\n\n","category":"type"},{"location":"results/#BraketSimulator.AdjointGradient","page":"Results","title":"BraketSimulator.AdjointGradient","text":"AdjointGradient <: Result\n\nStruct which represents a gradient computation using the adjoint differentiation method on a Circuit. \n\n\n\n\n\n","category":"type"},{"location":"results/#BraketSimulator.Expectation","page":"Results","title":"BraketSimulator.Expectation","text":"BraketSimulator.Expectation <: Result\n\nStruct which represents a expectation measurement on a Circuit. \n\n\n\n\n\n","category":"type"},{"location":"results/#BraketSimulator.Variance","page":"Results","title":"BraketSimulator.Variance","text":"BraketSimulator.Variance <: Result\n\nStruct which represents a variance measurement on a Circuit. \n\n\n\n\n\n","category":"type"},{"location":"results/#BraketSimulator.Sample","page":"Results","title":"BraketSimulator.Sample","text":"BraketSimulator.Sample <: Result\n\nStruct which represents a sample measurement on a Circuit. \n\n\n\n\n\n","category":"type"},{"location":"results/#BraketSimulator.Amplitude","page":"Results","title":"BraketSimulator.Amplitude","text":"Amplitude <: Result\n\nStruct which represents an amplitude measurement on a Circuit. \n\n\n\n\n\n","category":"type"},{"location":"results/#BraketSimulator.Probability","page":"Results","title":"BraketSimulator.Probability","text":"BraketSimulator.Probability <: Result\n\nStruct which represents a probability measurement on a Circuit. \n\n\n\n\n\n","category":"type"},{"location":"results/#BraketSimulator.DensityMatrix","page":"Results","title":"BraketSimulator.DensityMatrix","text":"BraketSimulator.DensityMatrix <: Result\n\nStruct which represents a densitymatrix measurement on a Circuit. \n\n\n\n\n\n","category":"type"},{"location":"results/#BraketSimulator.StateVector","page":"Results","title":"BraketSimulator.StateVector","text":"StateVector <: Result\n\nStruct which represents a state vector measurement on a Circuit. \n\n\n\n\n\n","category":"type"},{"location":"circuits/","page":"Circuits","title":"Circuits","text":"CurrentModule = BraketSimulator","category":"page"},{"location":"circuits/#Circuits","page":"Circuits","title":"Circuits","text":"","category":"section"},{"location":"circuits/","page":"Circuits","title":"Circuits","text":"Circuits are made up of instructions (operations to apply to the qubits – gates and noises) and result types (results). OpenQASM3 programs are parsed to circuits which are then run on the simulator.","category":"page"},{"location":"circuits/","page":"Circuits","title":"Circuits","text":"BraketSimulator.Circuit\nBraketSimulator.Operator\nBraketSimulator.QuantumOperator\nBraketSimulator.FreeParameter\nBraketSimulator.Reset\nBraketSimulator.Barrier\nBraketSimulator.Delay\nBraketSimulator.Measure\nBraketSimulator.Instruction\nBraketSimulator.QubitSet\nBraketSimulator.qubit_count\nBraketSimulator.qubits\nBraketSimulator.basis_rotation_instructions!","category":"page"},{"location":"circuits/#BraketSimulator.Circuit","page":"Circuits","title":"BraketSimulator.Circuit","text":"Circuit\n\nA representation of a quantum circuit that contains the instructions to be performed on a quantum device and the requested result types.\n\nSee:\n\nGates for all of the supported gates. \nNoises for all of the supported noise operations.\nResults for all of the supported result types.\n\n\n\n\n\n","category":"type"},{"location":"circuits/#BraketSimulator.Operator","page":"Circuits","title":"BraketSimulator.Operator","text":"Operator\n\nAbstract type representing operations that can be applied to a Circuit. Subtypes include Gate, Noise, Observable.\n\n\n\n\n\n","category":"type"},{"location":"circuits/#BraketSimulator.QuantumOperator","page":"Circuits","title":"BraketSimulator.QuantumOperator","text":"QuantumOperator < Operator\n\nAbstract type representing quantum operations that can be applied to a Circuit. Subtypes include Gate and Noise.\n\n\n\n\n\n","category":"type"},{"location":"circuits/#BraketSimulator.FreeParameter","page":"Circuits","title":"BraketSimulator.FreeParameter","text":"FreeParameter\nFreeParameter(name::Symbol) -> FreeParameter\n\nStruct representing a free parameter, which may be used to initialize to a parametrized Gate or Noise and then given a fixed value later by supplying a mapping to a Circuit.\n\n\n\n\n\n","category":"type"},{"location":"circuits/#BraketSimulator.Reset","page":"Circuits","title":"BraketSimulator.Reset","text":"Reset(index) <: QuantumOperator\n\nRepresents an active reset operation on targeted qubit, stored in the classical register at index. For now, this is a no-op.\n\n\n\n\n\n","category":"type"},{"location":"circuits/#BraketSimulator.Barrier","page":"Circuits","title":"BraketSimulator.Barrier","text":"Barrier(index) <: QuantumOperator\n\nRepresents a barrier operation on targeted qubit, stored in the classical register at index. For now, this is a no-op.\n\n\n\n\n\n","category":"type"},{"location":"circuits/#BraketSimulator.Delay","page":"Circuits","title":"BraketSimulator.Delay","text":"Delay(index, duration::Time) <: QuantumOperator\n\nRepresents a delay operation for duration on targeted qubit, stored in the classical register at index. For now, this is a no-op.\n\n\n\n\n\n","category":"type"},{"location":"circuits/#BraketSimulator.Measure","page":"Circuits","title":"BraketSimulator.Measure","text":"Measure(index) <: QuantumOperator\n\nRepresents a measurement operation on targeted qubit, stored in the classical register at index.\n\n\n\n\n\n","category":"type"},{"location":"circuits/#BraketSimulator.Instruction","page":"Circuits","title":"BraketSimulator.Instruction","text":"Instruction\nInstruction(o::Operator, target)\n\nRepresents a single operation applied to a Circuit. Contains an operator, which may be any subtype of Operator, and a target set of qubits to which the operator is applied.\n\nExamples\n\njulia> Instruction(H(), 1)\nInstruction{H}(H(1.0), QubitSet(1))\n\njulia> Instruction(CNot(), [1, 4])\nInstruction{CNot}(CNot(1.0), QubitSet(1, 4))\n\n\n\n\n\n","category":"type"},{"location":"circuits/#BraketSimulator.QubitSet","page":"Circuits","title":"BraketSimulator.QubitSet","text":"QubitSet\n\nAn OrderedSet-like object which represents the qubits a Circuit, Instruction, or Result acts on and their ordering.\n\nExamples\n\njulia> QubitSet([2, 1])\nQubitSet with 2 elements:\n  2\n  1\n\njulia> QubitSet()\nQubitSet()\n\njulia> QubitSet(QubitSet(5, 1))\nQubitSet with 2 elements:\n  5\n  1\n\n\n\n\n\n","category":"type"},{"location":"circuits/#BraketSimulator.qubit_count","page":"Circuits","title":"BraketSimulator.qubit_count","text":"qubit_count(c::Circuit) -> Int\n\nReturns the number of qubits that c is defined on.\n\nExamples\n\njulia> c = Circuit();\n\njulia> add_instruction!(c, Instruction(H(), 0));\n\njulia> add_instruction!(c, Instruction(CNot(), [0, 1]));\n\njulia> qubit_count(c)\n2\n\n\n\n\n\n","category":"function"},{"location":"circuits/#BraketSimulator.qubits","page":"Circuits","title":"BraketSimulator.qubits","text":"qubits(c::Circuit) -> QubitSet\n\nReturns a QubitSet containing all qubits that c is defined on.\n\nExamples\n\njulia> c = Circuit();\n\njulia> add_instruction!(c, Instruction(H(), 0));\n\njulia> add_instruction!(c, Instruction(CNot(), [0, 1]));\n\njulia> qubits(c)\nQubitSet with 2 elements:\n  0\n  1\n\n\n\n\n\n","category":"function"},{"location":"circuits/#BraketSimulator.basis_rotation_instructions!","page":"Circuits","title":"BraketSimulator.basis_rotation_instructions!","text":"basis_rotation_instructions!(c::Circuit)\n\nGets a list of basis rotation instructions and stores them in the circuit c. These basis rotation instructions are added if result types are requested for an observable other than Pauli-Z.\n\nThis only makes sense if all observables are simultaneously measurable; if not, this method will return an empty list.\n\n\n\n\n\n","category":"function"},{"location":"observables/#Observables","page":"Observables","title":"Observables","text":"","category":"section"},{"location":"observables/","page":"Observables","title":"Observables","text":"BraketSimulator.Observables.Observable\nBraketSimulator.Observables.X\nBraketSimulator.Observables.Y\nBraketSimulator.Observables.Z\nBraketSimulator.Observables.H\nBraketSimulator.Observables.I\nBraketSimulator.Observables.TensorProduct\nBraketSimulator.Observables.HermitianObservable\nBraketSimulator.Observables.Sum","category":"page"},{"location":"observables/#BraketSimulator.Observables.Observable","page":"Observables","title":"BraketSimulator.Observables.Observable","text":"Observable <: Operator\n\nAbstract type representing an observable to be measured. All Observables have eigvals defined.\n\nSee also: H, I, X, Y, Z, TensorProduct, HermitianObservable.\n\n\n\n\n\n","category":"type"},{"location":"observables/#BraketSimulator.Observables.X","page":"Observables","title":"BraketSimulator.Observables.X","text":"BraketSimulator.Observables.X <: Observable\nBraketSimulator.Observables.X([coeff::Float64]) -> BraketSimulator.Observables.X\n\nStruct representing a BraketSimulator.Observables.X observable in a measurement. The observable may be scaled by coeff.\n\n\n\n\n\n","category":"type"},{"location":"observables/#BraketSimulator.Observables.Y","page":"Observables","title":"BraketSimulator.Observables.Y","text":"BraketSimulator.Observables.Y <: Observable\nBraketSimulator.Observables.Y([coeff::Float64]) -> BraketSimulator.Observables.Y\n\nStruct representing a BraketSimulator.Observables.Y observable in a measurement. The observable may be scaled by coeff.\n\n\n\n\n\n","category":"type"},{"location":"observables/#BraketSimulator.Observables.Z","page":"Observables","title":"BraketSimulator.Observables.Z","text":"BraketSimulator.Observables.Z <: Observable\nBraketSimulator.Observables.Z([coeff::Float64]) -> BraketSimulator.Observables.Z\n\nStruct representing a BraketSimulator.Observables.Z observable in a measurement. The observable may be scaled by coeff.\n\n\n\n\n\n","category":"type"},{"location":"observables/#BraketSimulator.Observables.H","page":"Observables","title":"BraketSimulator.Observables.H","text":"BraketSimulator.Observables.H <: Observable\nBraketSimulator.Observables.H([coeff::Float64]) -> BraketSimulator.Observables.H\n\nStruct representing a BraketSimulator.Observables.H observable in a measurement. The observable may be scaled by coeff.\n\n\n\n\n\n","category":"type"},{"location":"observables/#BraketSimulator.Observables.I","page":"Observables","title":"BraketSimulator.Observables.I","text":"BraketSimulator.Observables.I <: Observable\nBraketSimulator.Observables.I([coeff::Float64]) -> BraketSimulator.Observables.I\n\nStruct representing a BraketSimulator.Observables.I observable in a measurement. The observable may be scaled by coeff.\n\n\n\n\n\n","category":"type"},{"location":"observables/#BraketSimulator.Observables.TensorProduct","page":"Observables","title":"BraketSimulator.Observables.TensorProduct","text":"TensorProduct <: Observable\nTensorProduct(factors::Vector{<:Observable}) -> TensorProduct\nTensorProduct(factors::Vector{String}) -> TensorProduct\n\nStruct representing a tensor product of smaller observables.\n\nExamples\n\njulia> BraketSimulator.Observables.TensorProduct([\"x\", \"h\"])\nX @ H\n\njulia> ho = BraketSimulator.Observables.HermitianObservable([0 1; 1 0]);\n\njulia> BraketSimulator.Observables.TensorProduct([ho, BraketSimulator.Observables.Z()])\nHermitianObservable((2, 2)) @ Z\n\n\n\n\n\n","category":"type"},{"location":"observables/#BraketSimulator.Observables.HermitianObservable","page":"Observables","title":"BraketSimulator.Observables.HermitianObservable","text":"HermitianObservable <: Observable\nHermitianObservable(matrix::Matrix) -> HermitianObservable\n\nStruct representing an observable of an arbitrary complex Hermitian matrix.\n\nExamples\n\njulia> ho = BraketSimulator.Observables.HermitianObservable([0 1; 1 0])\nHermitianObservable((2, 2))\n\n\n\n\n\n","category":"type"},{"location":"observables/#BraketSimulator.Observables.Sum","page":"Observables","title":"BraketSimulator.Observables.Sum","text":"Sum <: Observable\nSum(summands::Vector{<:Observable}) -> Sum\n\nStruct representing the sum of observables.\n\nExamples\n\njulia> o1 = 2.0 * BraketSimulator.Observables.I() * BraketSimulator.Observables.Z();\n\njulia> o2 = 3.0 * BraketSimulator.Observables.X() * BraketSimulator.Observables.X();\n\njulia> o = o1 + o2\nSum(2.0 * I @ Z, 3.0 * X @ X)\n\n\n\n\n\n","category":"type"},{"location":"noises/","page":"Noises","title":"Noises","text":"CurrentModule = BraketSimulator","category":"page"},{"location":"noises/#Noises","page":"Noises","title":"Noises","text":"","category":"section"},{"location":"noises/","page":"Noises","title":"Noises","text":"BraketSimulators.jl provides many pre-implemented noise channels which can be applied to circuits. Noisy circuits can be simulated used the density matrix simulator.","category":"page"},{"location":"noises/","page":"Noises","title":"Noises","text":"BraketSimulator.Noise\nBraketSimulator.Kraus\nBraketSimulator.BitFlip\nBraketSimulator.PhaseFlip\nBraketSimulator.PauliChannel\nBraketSimulator.TwoQubitPauliChannel\nBraketSimulator.MultiQubitPauliChannel\nBraketSimulator.Depolarizing\nBraketSimulator.PhaseDamping\nBraketSimulator.AmplitudeDamping\nBraketSimulator.GeneralizedAmplitudeDamping\nBraketSimulator.TwoQubitDepolarizing\nBraketSimulator.TwoQubitDephasing","category":"page"},{"location":"noises/#BraketSimulator.Noise","page":"Noises","title":"BraketSimulator.Noise","text":"Noise <: QuantumOperator\n\nAbstract type representing a quantum noise operation.\n\n\n\n\n\n","category":"type"},{"location":"noises/#BraketSimulator.Kraus","page":"Noises","title":"BraketSimulator.Kraus","text":"Kraus <: Noise\n\nKraus noise operation.\n\n\n\n\n\n","category":"type"},{"location":"noises/#BraketSimulator.BitFlip","page":"Noises","title":"BraketSimulator.BitFlip","text":"BitFlip <: Noise\n\nBitFlip noise operation.\n\n\n\n\n\n","category":"type"},{"location":"noises/#BraketSimulator.PhaseFlip","page":"Noises","title":"BraketSimulator.PhaseFlip","text":"PhaseFlip <: Noise\n\nPhaseFlip noise operation.\n\n\n\n\n\n","category":"type"},{"location":"noises/#BraketSimulator.PauliChannel","page":"Noises","title":"BraketSimulator.PauliChannel","text":"PauliChannel <: Noise\n\nPauliChannel noise operation.\n\n\n\n\n\n","category":"type"},{"location":"noises/#BraketSimulator.TwoQubitPauliChannel","page":"Noises","title":"BraketSimulator.TwoQubitPauliChannel","text":"TwoQubitPauliChannel <: Noise\n\nPauli channel noise operation on two qubits.\n\n\n\n\n\n","category":"type"},{"location":"noises/#BraketSimulator.MultiQubitPauliChannel","page":"Noises","title":"BraketSimulator.MultiQubitPauliChannel","text":"MultiQubitPauliChannel{N} <: Noise\n\nPauli channel noise operation on N qubits.\n\n\n\n\n\n","category":"type"},{"location":"noises/#BraketSimulator.Depolarizing","page":"Noises","title":"BraketSimulator.Depolarizing","text":"Depolarizing <: Noise\n\nDepolarizing noise operation.\n\n\n\n\n\n","category":"type"},{"location":"noises/#BraketSimulator.PhaseDamping","page":"Noises","title":"BraketSimulator.PhaseDamping","text":"PhaseDamping <: Noise\n\nPhaseDamping noise operation.\n\n\n\n\n\n","category":"type"},{"location":"noises/#BraketSimulator.AmplitudeDamping","page":"Noises","title":"BraketSimulator.AmplitudeDamping","text":"AmplitudeDamping <: Noise\n\nAmplitudeDamping noise operation.\n\n\n\n\n\n","category":"type"},{"location":"noises/#BraketSimulator.GeneralizedAmplitudeDamping","page":"Noises","title":"BraketSimulator.GeneralizedAmplitudeDamping","text":"GeneralizedAmplitudeDamping <: Noise\n\nGeneralizedAmplitudeDamping noise operation.\n\n\n\n\n\n","category":"type"},{"location":"noises/#BraketSimulator.TwoQubitDepolarizing","page":"Noises","title":"BraketSimulator.TwoQubitDepolarizing","text":"TwoQubitDepolarizing <: Noise\n\nTwoQubitDepolarizing noise operation.\n\n\n\n\n\n","category":"type"},{"location":"noises/#BraketSimulator.TwoQubitDephasing","page":"Noises","title":"BraketSimulator.TwoQubitDephasing","text":"TwoQubitDephasing <: Noise\n\nTwoQubitDephasing noise operation.\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"DocTestSetup = quote using BraketSimulator, BraketSimulator.Observables; using BraketSimulator: Program, Circuit, qubits, CNot, H, Rx, FreeParameter, QubitSet, AdjointGradient, BitFlip, qubit_count, Qubit, StateVector, Measure, Probability, Ry, Amplitude, Instruction, DensityMatrix, add_instruction! end\nCurrentModule = BraketSimulator","category":"page"},{"location":"#BraketSimulator","page":"Home","title":"BraketSimulator","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is a suite of Julia simulators of gate-based quantum circuits with (density matrix) and without (state vector) noise. It is designed to integrate with Amazon Braket, the quantum computing service from AWS. By default, it offers threaded CPU-based simulation of these circuits, and an optional package extension you can integrate with Python. To use the Python integration, you will need to install PythonCall.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the Julia Pkg docs for more information about package extensions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you wish to use this package from Python, see amazon-braket-simulator-v2, a Python package built on top of juliacall which will automatically install Julia and all necessary Julia packages in a Python virtual environment, set appropriate environment variables, and allow you to use these simulators from Python packages such as the Amazon Braket SDK or PennyLane.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In order to achieve the best performance for your simulations, you should set -t auto when you launch Julia or set the environment variable JULIA_NUM_THREADS to auto (the number of CPU threads).","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can install this package and its dependencies using the Julia package manager. Note that the minimum supported Julia version is 1.9. If you need to install Julia itself, follow the directions on the JuliaLang website.","category":"page"},{"location":"","page":"Home","title":"Home","text":"# install the package\nusing Pkg\nPkg.add(\"BraketSimulator\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then you can run a simulation of a simple GHZ state preparation circuit.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using BraketSimulator\n\njulia> using BraketSimulator: Circuit, H, CNot, Amplitude\n\njulia> n_qubits = 10;\n\njulia> c = Circuit();\n\njulia> add_instruction!(c, Instruction(H(), 0));\n\njulia> foreach(q->add_instruction!(c, Instruction(CNot(), [0, q])), 1:n_qubits-1);\n\njulia> push!(c.result_types, Amplitude([repeat(\"0\", n_qubits), repeat(\"1\", n_qubits)]));\n\njulia> sim = StateVectorSimulator(n_qubits, 0); # use the state vector simulator (without noise)\n\njulia> res = simulate(sim, Program(c), 0);\n\njulia> res.resultTypes[1].value\nDict{String, ComplexF64} with 2 entries:\n  \"0000000000\" => 0.707107+0.0im\n  \"1111111111\" => 0.707107+0.0im","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"CurrentModule = BraketSimulator","category":"page"},{"location":"internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"These functions are for internal use for preparing IRs for simulation and validating properties to make sure all instructions and results are supported.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"BraketSimulator._combine_operations\nBraketSimulator._prepare_program\nBraketSimulator._get_measured_qubits\nBraketSimulator._compute_results","category":"page"},{"location":"internals/#BraketSimulator._combine_operations","page":"Internals","title":"BraketSimulator._combine_operations","text":"_combine_operations(program, shots::Int) -> Program\n\nCombine explicit instructions and basis rotation instructions (if necessary). Validate that all operations are performed on qubits within qubit_count.\n\n\n\n\n\n","category":"function"},{"location":"internals/#BraketSimulator._prepare_program","page":"Internals","title":"BraketSimulator._prepare_program","text":"_prepare_program(circuit_ir::OpenQasmProgram, inputs::Dict{String, <:Any}, shots::Int) -> (Program, Int)\n\nParse the OpenQASM3 source, apply any inputs provided for the simulation, and compute basis rotation instructions if running with non-zero shots. Return the Program after parsing and the qubit count of the circuit.\n\n\n\n\n\n_prepare_program(circuit_ir::Program, inputs::Dict{String, <:Any}, shots::Int) -> (Program, Int)\n\nApply any inputs provided for the simulation. Return the Program (with bound parameters) and the qubit count of the circuit.\n\n\n\n\n\n","category":"function"},{"location":"internals/#BraketSimulator._get_measured_qubits","page":"Internals","title":"BraketSimulator._get_measured_qubits","text":"_get_measured_qubits(program, qubit_count::Int) -> Vector{Int}\n\nGet the qubits measured by the program. If Measure instructions are present in the program's instruction list, their targets are used to form the list of measured qubits. If not, all qubits from 0 to qubit_count-1 are measured. \n\n\n\n\n\n","category":"function"},{"location":"internals/#BraketSimulator._compute_results","page":"Internals","title":"BraketSimulator._compute_results","text":"_compute_results(::, simulator, program::Program, n_qubits::Int, shots::Int) -> Vector{ResultTypeValue}\n\nCompute the results once simulator has finished applying all the instructions. The results depend on the IR type if shots>0:\n\nFor JAQCD IR (Program), the results array is empty because the Braket SDK computes the results from the IR directly.\nFor OpenQASM IR (OpenQasmProgram), the results array is empty only if no results are present in the parsed IR. Otherwise, the results array is populated with the parsed result types (to help the Braket SDK compute them from the sampled measurements) and a placeholder zero value.\n\n\n\n\n\n","category":"function"},{"location":"sims/","page":"Simulators","title":"Simulators","text":"CurrentModule = BraketSimulator","category":"page"},{"location":"sims/#Simulators","page":"Simulators","title":"Simulators","text":"","category":"section"},{"location":"sims/","page":"Simulators","title":"Simulators","text":"BraketSimulators.jl provides two types of simulators: StateVectorSimulator for pure state simulation (without noise) and DensityMatrixSimulator for noisy simulation. Each type is parameterized by an element type (which should be a Julia Complex type, such as ComplexF64) and an array type (so that we can specialize for GPU arrays, for example).","category":"page"},{"location":"sims/","page":"Simulators","title":"Simulators","text":"Each simulator can be initialized with a qubit_count and shots value. You may query the properties of a simulator to learn what gate types, result types, and other operations it supports.","category":"page"},{"location":"sims/","page":"Simulators","title":"Simulators","text":"StateVectorSimulator\nDensityMatrixSimulator\nevolve!\nsimulate\nexpectation\nprobabilities\nBraketSimulator.properties","category":"page"},{"location":"sims/#BraketSimulator.StateVectorSimulator","page":"Simulators","title":"BraketSimulator.StateVectorSimulator","text":"StateVectorSimulator{T, S<:AbstractVector{T}} <: AbstractSimulator\n\nSimulator representing a pure state evolution of a statevector of type S, with element type T. State vector simulators should be used to simulate circuits without noise.\n\n\n\n\n\n","category":"type"},{"location":"sims/#BraketSimulator.DensityMatrixSimulator","page":"Simulators","title":"BraketSimulator.DensityMatrixSimulator","text":"DensityMatrixSimulator{T, S<:AbstractMatrix{T}} <: AbstractSimulator\n\nSimulator representing evolution of a density matrix of type S, with element type T. Density matrix simulators should be used to simulate circuits with noise.\n\n\n\n\n\n","category":"type"},{"location":"sims/#BraketSimulator.evolve!","page":"Simulators","title":"BraketSimulator.evolve!","text":"evolve!(svs::StateVectorSimulator{T, S<:AbstractVector{T}}, operations::Vector{Instruction}) -> StateVectorSimulator{T, S}\n\nApply each operation of operations in-place to the state vector contained in svs.\n\nEffectively, perform the operation:\n\nleft psi rightrangle to hatA left psi rightrangle\n\nfor each operation hatA in operations.\n\n\n\n\n\nevolve!(dms::DensityMatrixSimulator{T, S<:AbstractMatrix{T}}, operations::Vector{Instruction}) -> DensityMatrixSimulator{T, S}\n\nApply each operation of operations in-place to the density matrix contained in dms.\n\nEffectively, perform the operation:\n\nhatrho to hatA^dag hatrho hatA\n\nfor each operation hatA in operations.\n\n\n\n\n\n","category":"function"},{"location":"sims/#BraketSimulator.simulate","page":"Simulators","title":"BraketSimulator.simulate","text":"simulate(simulator::AbstractSimulator, circuit_ir::Union{OpenQasmProgram, Program}, shots::Int; kwargs...) -> GateModelTaskResult\n\nSimulate the evolution of a state vector or density matrix using the passed-in simulator. The instructions to apply (gates and noise channels) and measurements to make are encoded in circuit_ir. Supported IR formats are OpenQASMProgram (OpenQASM3) and Program (JAQCD). Returns a GateModelTaskResult containing the individual shot measurements (if shots > 0), final calculated results, circuit IR, and metadata about the task.\n\n\n\n\n\nsimulate(simulator::AbstractSimulator, circuit_irs::Vector{<:Union{Program, OpenQasmProgram}}, shots::Int; max_parallel::Int=min(32, Threads.nthreads()), inputs=Dict{String,Float64}(), kwargs...) -> Vector{GateModelTaskResult}\n\nSimulate the evolution of a batch of state vectors or density matrices using the passed in simulator. The instructions to apply (gates and noise channels) and measurements to make are encoded in circuit_irs. Supported IR formats are OpenQASMProgram (OpenQASM3) and Program (JAQCD).\n\nThe simulation of the batch is done in parallel using threads. The keyword argument max_parallel specifies the number of evolutions to simulate in parallel – the default value is whichever of 32 and Threads.nthreads() is smaller. This is to avoid overwhelming the thread scheduler with too many small tasks waiting to run, as each evolution is itself threaded. This value may change in the future.\n\nThe inputs keyword argument can be a Dict{String} or a Vector{Dict{String}}. In the first case, the same input values are applied to all circuit_irs. In the second, the length of the inputs must be the same as the length of circuit_irs, and the n-th inputs is applied to the n-th circuit_irs.\n\nReturns a Vector{GateModelTaskResult}, each element of which contains the individual shot measurements (if shots > 0), final calculated results, corresponding circuit IR, and metadata about the task.\n\n\n\n\n\n","category":"function"},{"location":"sims/#BraketSimulator.expectation","page":"Simulators","title":"BraketSimulator.expectation","text":"expectation(svs::StateVectorSimulator, observable::Observables.Observable, targets::Int...) -> Float64\n\nCompute the exact (shots=0) expectation value of observable applied to targets given the evolved state vector in svs. In other words, compute\n\nlangle psi  hatO  psi rangle.\n\n\n\n\n\nexpectation(dms::DensityMatrixSimulator, observable::Observables.Observable, targets::Int...) -> Float64\n\nCompute the exact (shots=0) expectation value of observable applied to targets given the evolved density matrix in dms. In other words, compute\n\nmathrmTrleft(hatOhatrhoright).\n\n\n\n\n\n","category":"function"},{"location":"sims/#BraketSimulator.probabilities","page":"Simulators","title":"BraketSimulator.probabilities","text":"probabilities(svs::StateVectorSimulator) -> Vector{Float64}\n\nCompute the observation probabilities of all amplitudes in the state vector in svs.\n\n\n\n\n\n","category":"function"},{"location":"sims/#BraketSimulator.properties","page":"Simulators","title":"BraketSimulator.properties","text":"properties(svs::StateVectorSimulator) -> GateModelSimulatorDeviceCapabilities\n\nQuery the properties and capabilities of a StateVectorSimulator, including which gates and result types are supported and the minimum and maximum shot and qubit counts.\n\n\n\n\n\nproperties(svs::DensityMatrixSimulator) -> GateModelSimulatorDeviceCapabilities\n\nQuery the properties and capabilities of a DensityMatrixSimulator, including which gates and result types are supported and the minimum and maximum shot and qubit counts.\n\n\n\n\n\n","category":"function"}]
}
